---
layout: post
title: Arboles de expresión y reflexión estática
date: '2017-12-02T10:54:00.000-08:00'
author: Jesús
tags:
- Programación Orientada a Objetos
- C#
- Unobstrusive Validation
- Métodos de extensión
- Reflexión
- IEnumerable
- Reflexión estática
- IQuereyable
- Linq
- Arboles de Expresión
- HtmlHelper
- ASP Net MVC
modified_time: '2017-12-07T11:52:40.480-08:00'
thumbnail: https://4.bp.blogspot.com/-xiDQny1NjhA/WigOrMkUu_I/AAAAAAAAIoU/ez5d7TRmFtIPAJrbr7iBbTpD2EOlkrBiACLcBGAs/s72-c/Arbol1.png
blogger_id: tag:blogger.com,1999:blog-3773544929012013646.post-643182983803693476
blogger_orig_url: https://codigo418.blogspot.com/2017/11/arboles-de-expresiones-y-reflexion.html
---

<h1>Arboles de expresión</h1>Un árbol de expresión es una expresión lambda sin compilar. Cuando utilizamos un árbol de expresión, el código de la expresión lambda se mantiene en memoria en forma de estructura de árbol binario. Se almacenan las partes de la expresión y las operaciones entre las partes por separado en una estructura de árbol. En este estructura los nodos representan operadores y las hojas representan valores. De esta forma es posible representar cualquier operación como una jerarquía. Veamos un ejemplo de árbol de expresión binario muy simple:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-xiDQny1NjhA/WigOrMkUu_I/AAAAAAAAIoU/ez5d7TRmFtIPAJrbr7iBbTpD2EOlkrBiACLcBGAs/s1600/Arbol1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="215" data-original-width="213" src="https://4.bp.blogspot.com/-xiDQny1NjhA/WigOrMkUu_I/AAAAAAAAIoU/ez5d7TRmFtIPAJrbr7iBbTpD2EOlkrBiACLcBGAs/s1600/Arbol1.png" /></a></div><br />En el ejemplo, si partimos de las hojas hacia la raíz nos encontramos primero con los valores 20 y 5 cuyo nodo común es el operador suma, por lo que el operador podría sustituirse por el valor resultado de la suma: 25.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-tsOMUn18Ud0/WigOrGD4P0I/AAAAAAAAIoY/yn7-lG2YORgnkzHGnUHGgYYeUNWAB4vNwCEwYBhgL/s1600/Arbol2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="215" data-original-width="213" src="https://2.bp.blogspot.com/-tsOMUn18Ud0/WigOrGD4P0I/AAAAAAAAIoY/yn7-lG2YORgnkzHGnUHGgYYeUNWAB4vNwCEwYBhgL/s1600/Arbol2.png" /></a></div><br />A continuación tendríamos dos hojas con los valores 25 y 10 con un nodo común con la operación multiplicar, por lo que el resultado de ambos será de 25 multiplicado por 10: 250. Al ser la raíz del árbol este sería el valor del resultado de la expresión.<br /><br />Las expresiones suelen ser mucho más complejas que en el ejemplo y en vez de valores constantes podemos tener variables y llamadas a métodos. También tendremos en el árbol una rama que representará los parámetros de entrada de la expresión. <br /><br />Veamos ahora un ejemplo de una expresión lambda y su árbol de expresión equivalente. Como se puede observar, para invocar la función del árbol de expresión es necesario compilarla primero para que devuelva su delegado equivalente. El resultado de la invocación es el mismo en ambos casos: <br /><script src="https://gist.github.com/jesuscampos/64936f86ae3eb0e4d5ff1b7fae932ae4.js"></script>Aunque ambas expresiones representan la misma función, la primera de ellas se compila en tiempo de compilación y no guarda ninguna información de la expresión origen. Se limita a ejecutar la función para la que ha sido creada. Se trata simplemente de un delegado que apunta a un método. Sin embargo, la segunda guarda la expresión tal cual, es decir, podemos estudiar por separado cada nodo y cada hoja de la expresión en tiempo de ejecución. También podemos compilar la expresión en tiempo de ejecución e invocarla como si fuera una expresión lambda normal. <br /><br />Es muy habitual que un método nos solicite un árbol de expresión como parámetro y que la expresión nunca sea compilada ni ejecutada. En estos casos el parámetro tiene el único propósito de informar en detalle cómo está estructurada la función. Más adelante veremos algunos ejemplos donde se entenderá mejor este aspecto.<br /><misnotas>Mientras una expresión lambda ejecuta código, un árbol de expresión describe lo que hace ese código.</misnotas><h1>Reflexión estática</h1>Un árbol de expresión tiene la ventaja de poder ser analizada miembro a miembro utilizando la reflexión estática. Veamos cómo convierte el compilador un árbol de expresión en una estructura de datos. <br /><br />En el siguiente ejemplo se muestra un árbol de expresión y a continuación la forma en que el compilador la descompondrá en miembros de una estructura. En realidad las dos formas son válidas para declarar un árbol de expresión, sin embargo, la forma más rápida e intuitiva es la primera donde se utiliza la sintaxis de expresión lambda: [parámetros] =&gt; [cuerpo de la expresión]. La segunda forma nos ofrecería la capacidad de "montar al vuelo" una función con estructura de árbol binario, permitiendo crear métodos dinámicos de una forma muy simple. <br /><script src="https://gist.github.com/jesuscampos/eeec08070ab1c5b0610b1a6ced061568.js"></script>La expresión anterior se compone de distintos miembros formando la siguiente estructura de árbol:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-_cFkp4WH24w/WigOrK97QVI/AAAAAAAAIoQ/iecxisA1Xnw7LCWrLhC5kGYpzZoleR7GgCEwYBhgL/s1600/ExpresionArbol.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="263" data-original-width="547" src="https://3.bp.blogspot.com/-_cFkp4WH24w/WigOrK97QVI/AAAAAAAAIoQ/iecxisA1Xnw7LCWrLhC5kGYpzZoleR7GgCEwYBhgL/s1600/ExpresionArbol.png" /></a></div><br />De forma inversa, a partir de un árbol de expresión, podemos descomponerla en sus miembros individuales y analizar cada miembro por separado.<br />A esta forma de análisis, muy similar a la reflexión dinámica que utilizamos para el análisis de tipos, se le llama <b>reflexión estática</b>. El siguiente código realiza una simple inspección de la expresión <code>EsVip</code> utilizada en el ejemplo anterior: <script src="https://gist.github.com/jesuscampos/bf3fbe7c34068fc32721baad8b3a207f.js"></script>Resultado: <command-line>Expression: c =&gt; (c.Volumen &gt; 20000)<br />Tipo expression: Lambda<br />Tipo de volor devulto: System.Boolean<br />Nombre parámetro: c<br />Tipo parámetro: Clientes<br />Expresión izda: c.Volumen<br />Expresión dcha: 20000<br />Tipo de nodo: GreaterThan_</command-line><br /><h2>Ventajas y usos de la reflexión estática</h2>La reflexión estática recopila información inspeccionando un árbol de expresión. La reflexión dinámica permite obtener información de los ensamblados y los tipos definidos dentro de ellos.<br /><br />La principal ventaja que ofrece la reflexión estática es que utiliza código <b>tipado</b>. De esta forma nos aseguramos tener siempre un código válido. Por el contrario, la reflexión dinámica utiliza cadenas de texto "magic strings" que dan pie a errores de tipografía. Además, la reflexión estática permite utilizar <b>Intellisense</b> de Visual Studio para mayor productividad y comodidad así como realizar refactorizaciones automáticas sin preocuparnos de romper el código.<br /><br />Examinemos los dos tipos de reflexión con el siguiente ejemplo que simplemente comprueba si una propiedad está marcada o no con el atributo <code>ObsoleteAttribute</code>:<br /><script src="https://gist.github.com/jesuscampos/9a2835c39b0e6c7a262634ff4d9106e2.js"></script>En el primer método necesitamos pasar un "magic string" ya que el método emplea reflexión dinámica. Además, al pasarle un simple <code>string</code>, no tiene información relativa al objeto sobre el que queremos examinar la propiedad. Podemos solucionarlo añadiendo un parámetro más con el objeto a examinar o, tal y como hemos hecho en el ejemplo, utilizando un método genérico donde el tipo genérico establece el tipo de objeto.<br /><br />El segundo método acepta un árbol de expresión, ofreciendo un tipado seguro. En este caso estamos pasando en un mismo parámetro toda la información necesaria para examinar la propiedad.<br /><br />Este sería el código que podría usarse dentro de cada uno de los métodos anteriores:<br /><script src="https://gist.github.com/jesuscampos/67c137f23ceca6356aa49e79f4b17d89.js"></script> <br /><h2>Ejemplos de uso de las expresiones de árbol</h2><h3>Proveedores de consultas</h3>Tanto <b>Linq to SQL</b> como <b>Linq to Entities (Entity Framework)</b> necesitan transformar expresiones descritas en código .Net a su expresión equivalente en SQL antes de enviar la consulta al servidor. Examinemos por ejemplo la siguiente expresión utilizada en Entity Framework sobre el método <code>Where</code> donde podemos especificar un predicado para obtener una colección filtrada de una entidad: <script src="https://gist.github.com/jesuscampos/ffba249f745c7d4e1b4dcea82f08dab6.js"></script>El método <code>Where</code> acepta un árbol de expresión con un delegado de tipo <code>Func</code> con un parámetro de entrada del tipo de la entidad sobre la que estamos invocando el <code>Where</code>, en nuestro caso <code>Clientes</code>, y con un parámetro de salida de tipo booleano. Entity Framework nos devolverá los clientes cuya función devuelva un valor true. ¿Cómo es capaz Entity Framework de generar la consulta SQL necesaria para cualquier función que nosotros le indiquemos? <br /><br />La respuesta está en el árbol de expresión. Entity Framework no necesita compilar ni ejecutar la expresión que le hemos pasado. Lo que necesita es convertir los miembros descritos en la expresión en una cadena de consulta propia del lenguaje SQL. El caso anterior lo que hace es convertir el árbol de expresión en la cosulta: <script src="https://gist.github.com/jesuscampos/507ff8e3d961b3c0819e5bfd91aca3c0.js"></script>El siguiente código, al añadir el método <code>Select</code> y realizar una proyección sobre un sólo campo, la consulta que utiliza Entity Framework se simplifica:<br /><script src="https://gist.github.com/jesuscampos/26e816f91eeaf3a8de3fef6f8b56fca9.js"></script>La librería estándar de Linq trabaja con colecciones que implementan la interfaz <code>IEnumerable</code>, y Linq to SQL y Linq to Entities trabajan con colecciones que implementan la interfaz <code>IQuereyable</code>. <br /><br />A su vez, los métodos de extensión de <code>IEnumerable</code> esperan parámetros delegados y los métodos de extensión de <code>IQuereyable</code> esperan parámetros de expresiones de árbol.<br /><br />Estas dos son las firmas del método <code>Where</code> de una colección <code>IEnumerable</code> y de una colección <code>IQuereyable</code>. Como se puede apreciar son equivalentes: <script src="https://gist.github.com/jesuscampos/6d7eeb31b6b229428e9b18c8c467c7ff.js"></script>Así como <code>IEnumerable</code> garantiza que una colección puede ser tratada como tal e iterada en un bucle <code>foreach</code>, la interfaz <code>IQuereyable</code>, además de implementar también la interfaz <code>IEnumerable</code>, es capaz de realizar consultas por medio de un objeto <code>Provider</code> proporcionado por la interfaz. El proveedor examinará el árbol de expresión y deberá "traducirla" a su consulta equivalente comprensible por el proveedor. <br /><h3>Métodos de extensión de HtmlHelper en ASP Net MVC</h3>Observemos las siguientes líneas de código muy habituales en vistas razor para ASP Net MVC: <script src="https://gist.github.com/jesuscampos/a13db74ceb5b163bd5b75421d9e6c8e0.js"></script><code>@Html</code> es un objeto de tipo <code>HtmlHelper</code> que nos ayuda a generar código Html en una vista razor. Este objeto cuenta con una serie de métodos de extensión que aceptan parámetros de tipo árbol de expresión como por ejemplo: <code>DisplayNameFor</code>, <code>DisplayFor</code>, <code>CheckBoxFor</code>, <code>HiddenFor</code>, <code>DisplayForModel</code>, etc. Estos métodos, además de ofrecernos un tipado fuerte sin opción a errores, proporcionan al objeto <code>HtmlHelper</code> una información extra en el árbol de expresión. <br /><br />Además de poder compilar e invocar el método para obtener el valor de la propiedad <code>Nombre</code> del modelo, a través del árbol de expresión, analizará tanto el parámetro de entrada (<code>model</code>) como la propiedad seleccionada en el cuerpo de la expresión (<code>model.Nombre</code>). <br /><br />De esta manera será capaz de analizar por reflexión los atributos especificados en las propiedades del objeto Cliente. <br /><br />Esto es muy útil para la representación en la vista de las etiquetas, sus valores e incluso para añadir al código Html todos los atributos necesarios de tipo <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/data-*">data-*</a>&nbsp;para la validación de campos de los formularios. ASP Net MVC, junto a la librería de <b>jQuery Unobstrusive Validation</b> ofrecen funcionalidad para la representación de los atributos necesarios para realizar la validación en el cliente. <br /><br />Veamos un ejemplo con el siguiente modelo y vista de <code>Cliente</code>: <script src="https://gist.github.com/jesuscampos/c37512816f270ad1b41f30d68e9b619a.js"></script>Gracias a los métodos <code>DisplayNameFor</code> y <code>DisplayFor</code>, que aceptan un árbol de expresión como parámetro, obtenemos una representación como la siguiente:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-QeDea1aYvDY/WifpHF2xCKI/AAAAAAAAIn0/bhD06Nrjn2gHzpr8_Lh1Qf1r-zaUxhYTgCPcBGAYYCw/s1600/Vista1.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="234" data-original-width="334" src="https://3.bp.blogspot.com/-QeDea1aYvDY/WifpHF2xCKI/AAAAAAAAIn0/bhD06Nrjn2gHzpr8_Lh1Qf1r-zaUxhYTgCPcBGAYYCw/s1600/Vista1.PNG" /></a></div><br />Como se puede observar se ha utilizado el atributo <code>DisplayName</code> del modelo para la representación de las etiquetas de cada campo.<br /><br />Sin embargo, lo mejor viene para las vistas de edición donde tenemos un formulario con entrada de datos. Continuando con el modelo <code>Cliente</code> del mismo ejemplo, veamos la siguiente vista de edición: <script src="https://gist.github.com/jesuscampos/b75bea8c5d51dc019e9a3d89bab07fcf.js"></script>Gracias a los atributos utilizados en el modelo (<code>DisplayName</code>, <code>Required</code>, <code>Range</code>...) y los métodos de extensión <code>LabelFor</code>, <code>EditorFor</code> y <code>ValidationMessageFor</code>, los cuales aceptan un árbol de expresión como parámetro, obtenemos el código Html necesario para la representación de las etiquetas, la validación en cliente y los textos de error producidos en la validación.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-HwZYDRPgyV8/WifpHFbAx7I/AAAAAAAAIn0/2n3SW0bkpKEzMM1-t95kIQDgNVOpbR2BQCPcBGAYYCw/s1600/Validaciones.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="212" data-original-width="416" src="https://1.bp.blogspot.com/-HwZYDRPgyV8/WifpHFbAx7I/AAAAAAAAIn0/2n3SW0bkpKEzMM1-t95kIQDgNVOpbR2BQCPcBGAYYCw/s1600/Validaciones.PNG" /></a></div><br />Este sería el código generado de forma totalmente automática para el campo de texto de IdCliente:<br /><script src="https://gist.github.com/jesuscampos/7fb26fdae9d8985455d7f3629a748bd8.js"></script>Cuando el usuario pulse sobre el botón para enviar el formulario, la librería jQuery Unobstrusive Validation se encargará de analizar los datos introducidos con ayuda de los atributos data-* proporcionados.<br /><br />Si queremos personalizar la forma en que se representa el código Html recomiendo implementar nuestro propio método de extensión para que se pueda usar desde la vista. Podemos personalizar nuestros propios atributos y aplicar lógica adicional para moldear la representación final. Incluso podemos hacer que envuelva a uno de los métodos proporcionados por ASP Net MVC y decorarlo con nuestra lógica.<br /><br />El siguiente ejemplo muestra un método de extensión del objeto <code>HtmlHelper</code> en el que comprobamos la existencia del atributo personalizado <code>AlineamientoAttribute</code> en la propiedad de nuestro modelo y según el valor de su propiedad <code>Alinamiento</code> añadimos una clase css distinta al código Html generado:<br /><script src="https://gist.github.com/jesuscampos/bdec204e1cc23202ee4fb9181072787f.js"></script>El atributo personalizado podría ser como el siguiente:<br /><script src="https://gist.github.com/jesuscampos/a4865ae280a1d4c2fe8948e5e9d70a95.js"></script>