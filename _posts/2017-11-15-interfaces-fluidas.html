---
layout: post
title: Interfaces fluidas
date: '2017-11-15T03:32:00.000-08:00'
author: Jesús
tags:
- Method chaining
- Delegados
- Fluid Interface
- C
- Interfaz fluida
- Ley de Demeter
- IEnumerable
- Linq
- Arboles de Expresión
- Genéricos
- POO
- Expresiones lambda
- Encadenamiento de métodos
modified_time: '2017-12-07T11:43:43.040-08:00'
blogger_id: tag:blogger.com,1999:blog-3773544929012013646.post-8476170940184280769
blogger_orig_url: https://codigo418.blogspot.com/2017/12/interfaces-fluidas.html
---

<h1>Introducción</h1>Martin Fowler definió la técnica <a href="https://martinfowler.com/bliki/FluentInterface.html">Interfaz fluida (Fluent Interface)</a> como un estilo para construir interfaces (APIs) orientadas a objetos que nos permite escribir un código fácilmente <b>leíble</b>. <br /><br />A continuación, mostraré como se implementa esta técnica con el encadenamiento de métodos <a href="https://en.wikipedia.org/wiki/Method_chaining">(Method Chaining)</a>. Después ampliaré el post para ver esta misma técnica con métodos que aceptan como parámetros a delegados (<code>Actions</code> o <code>Functions</code>), dando una mayor flexibilidad y expresividad a esta técnica. <br /><br />Son muchos los frameworks que implementan esta técnica y muchos de ellos empleando delegados. Muchos de ellos los utilizamos a diario como consumidores y poco a poco nos hemos acostumbrado a ellos. Ahora veremos como implementarlos nosotros mismos para nuestras propias interfaces. <br /><br />Suelen emplearse para realizar acciones secuenciales sobre un mismo objeto. Tal es el caso de las parametrizaciones y transformaciones de los objetos complejos. <br /><h1>Encadenamiento de métodos</h1>Esta técnica consiste en que cada método de un objeto devuelve el propio objeto o al menos un objeto del mismo tipo, permitiendo encadenar las llamadas juntas en una misma sentencia evitando la necesidad de ir guardando los resultados en variables intermedias. <br /><br />En el ejemplo siguiente, los métodos de la clase <code>Persona</code>, además de realizar su trabajo específico, devuelven el propio objeto para que el consumidor pueda encadenar las llamadas a sus métodos: <script src="https://gist.github.com/jesuscampos/cd82327a3c756e38a5a4bca8bf140649.js"></script>Y el uso sería: <br /><script src="https://gist.github.com/jesuscampos/52bc85f15cfc12f862fb880e2e687390.js"></script>Aunque puede haber un método finalizador que desencadene una última acción sobre el objeto final no es obligatorio. En caso de existir este método podría no devolver nada (void). El patrón <b>Builder</b> permite encadenar varios métodos de parametrización sobre un objeto builder y terminar con una llamada a un método <code>build</code> que nos devuelve una instancia con las características especificadas. El siguiente ejemplo muestra como .Net Core 2.0 configura el objeto <code>IWebHost</code> haciendo uso de un builder: <script src="https://gist.github.com/jesuscampos/befab3480933acb105f288f18bf18a5c.js"></script>El método <code>CreateDefaultBuilder</code> devuelve un objeto <code>IWebHostBuilder</code> con el que podemos encadenar la configuración del Host con las sucesivas llamadas a métodos en cadena. El último método <code>build</code> se encarga de crear una instancia de un objeto <code>IWebHost</code> con la configuración especificada. <br /><br />En el siguiente ejemplo podemos ver la interfaz fluida de la clase <code>StringBuilder</code>&nbsp;de la librería System.Text. Construimos una cadena de texto encadenando métodos <code>Append</code> y <code>AppendLine</code> gracias a que estos métodos devuelven el propio objeto <code>StringBuilder</code>: <br /><script src="https://gist.github.com/jesuscampos/6b4b634013ffef2e95c03eb5a62d671c.js"></script>Como podemos observar esta técnica permite escribir una <b>frase</b> uniendo invocaciones a métodos en una misma sentencia. Si a la hora de diseñar la interfaz utilizamos nombres descriptivos de los métodos estaremos dando valor semántico a nuestro código, y por lo tanto escribiremos código compresible y auto-descriptivo. Imaginemos una interfaz que nos permita escribir un código como este: <br /><script src="https://gist.github.com/jesuscampos/d14b3c5e9bc9ae691be2d3305d3418c0.js"></script>Incluso sin ser programador se intuye el significado del código anterior. Esto es a lo que Martin Fowler se refiere con interfaz <b>leíble</b>. <br /><br />En el ejemplo, el método <code>FabricarCoche</code> devuelve un objeto <code>Coche</code>. Este objeto implementa una interfaz fluida con la que podemos configurar nuestro coche a nuestro gusto. <br /><br />Hay que destacar que ni hay un orden obligatorio de invocación ni es necesario llamar a todos y cada uno de los métodos. El consumidor elige qué métodos quiere invocar y en qué orden lo hace. <br /><br />Que no exista un orden forzoso es intrínseco a la técnica, ya que tendremos acceso a todos los métodos de la interfaz visibles del objeto, estemos en el punto que estemos de la cadena. Si nuestro diseño necesita de una secuencia concreta de invocación deberíamos estudiar otra técnica más adecuada en la que el consumidor no tenga la libertad que ofrece la interfaz fluida. <br /><br />Eso sí, que sea libre el orden no significa que los resultados deban ser los mismos. Esto depende de la implementación de cada caso particular. Tenemos un ejemplo muy claro con el objeto <code>StringBuilder</code>. Las dos líneas siguientes no son equivalentes: <script src="https://gist.github.com/jesuscampos/36b99665c5b00461dd56dfe5bab459c4.js"></script><br /><h2>Mutando tipos genéricos</h2>Se puede usar la interfaz fluida con tipos genéricos igual que con tipos normales. Incluso se pueda dar el caso que tengamos métodos encadenables que muten el tipo genérico. Para este caso, el objeto sobre el que invocamos el método no será el mismo que devuelva el método. Se devolverá un nuevo objeto del mismo tipo pero con un distinto tipo genérico. Esto es debido a que un tipo genérico no puede cambiar el tipo de su genérico en tiempo de ejecución. Más adelante se verá con más detalle como trabajan los métodos de extensión de la librería Linq del Framework .Net sobre colecciones y como algunos de sus métodos encadenables realizan estas transformaciones sobre los elementos de las colecciones. <br /><br />Antes mostraré un ejemplo muy sencillo donde una interfaz fluida sobre un objeto genérico puede realizar una mutación a un nuevo objeto con un genérico distinto.<br /><br /><script src="https://gist.github.com/jesuscampos/8fffc3a5d334ea11ef9fe5d8a99e0553.js"></script>En el ejemplo los métodos <code>Pintar</code>, <code>ConGps</code>, <code>Mutar</code> y <code>MutarABarco</code> forman la interfaz fluida de la clase <code>Garaje</code>. Mientras los métodos <code>Pintar</code> y <code>ConGps</code> actúan sobre el propio objeto, el método <code>Mutar</code> crea un nuevo objeto con un tipo genérico resuelto en la llamada y el método <code>MutarABarco</code> crea un nuevo objeto con el tipo genérico <code>Barco</code>. <br /><br />El consumidor puede emplear la interfaz de la siguiente manera: <script src="https://gist.github.com/jesuscampos/bd3d082bda5b06ecd8075ad5a566d3c3.js"></script>Resultado:<br /><command-line>TipoVehiculo: Barco, Color: Verde, Gps: Sí_</command-line><br />En el ejemplo se crea un objeto <code>Garaje</code> con tipo genérico <code>Coche</code>. A continuación utiliza la interfaz fluida llamando a los métodos: <br /><ul style="text-align: justify;"><li><code>Pintar</code> y <code>ConGps</code>: ambos actúan sobre el objeto con genérico <code>Coche</code> que hemos creado y devuelven el mismo objeto.</li><li><code>Mutar</code>: A partir del objeto con genérico <code>Coche</code> crea un nuevo objeto con genérico <code>Moto</code> y lo devuelve.</li><li><code>MutarABarco</code>: A partir del objeto con genérico <code>Moto</code> crea un nuevo objeto con genérico <code>Barco</code> y lo devuelve.</li></ul><misnotas><h3>Ley de Demeter</h3>Aunque en el post anterior de&nbsp;<a href="https://codigoofuscado.wordpress.com/2017/10/29/composicion-o-herencia-ser-o-tener/">Composición o herencia: Ser o tener</a>&nbsp;comenté que el encadenamiento de métodos viola la&nbsp;<a href="https://es.wikipedia.org/wiki/Ley_de_Demeter">Ley de Demeter</a>, en el caso de interfaces fluidas siempre devolvemos el mismo tipo de objeto, por lo que no estamos saliendo nunca de la relación entre el consumidor y el objeto respetando así esta ley. Recordemos que la Ley de Demeter se viola cuando la cadena de métodos va trabajando sobre objetos distintos en cada invocación, ya que en cada método introducimos una nueva dependencia. </misnotas><br /><h2>Interfaz fluida compleja o anidada</h2>Las interfaces fluidas nos permiten trabajar con objetos compuestos de otros objetos que a su vez utilizan también sus propias interfaces fluidas. Esto permite encadenar métodos a distintos niveles. En el siguiente ejemplo hemos diseñado una interfaz fluida compleja:<br /><br /><script src="https://gist.github.com/jesuscampos/0434978f6902de571b055912f185a228.js"></script>Esta vez, el método <code>ConMotor</code> acepta un objeto <code>Motor</code> como parámetro. En lugar de pasarle un objeto <code>Motor</code> llamamos al método <code>FabricarMotor</code>, el cual nos devuelve un nuevo objeto <code>Motor</code>. Este objeto implementa su propia interfaz fluida para configurar el motor del coche. <br /><br />En la siguiente sección daremos un paso más en fluidez utilizando expresiones lambda como parámetros. También veremos en detalle la interfaz fluida que utiliza Linq con objetos IEnumerables.<br /><h1>Usando Lambdas</h1><span style="text-align: justify;">Al usar delegados en los parámetros de nuestros métodos estamos delegando en el consumidor parte de la responsabilidad de su comportamiento. Si estos delegados además son sencillos se pueden implementar mediante expresiones lambda dando a las sentencias de métodos encadenados mayor expresividad.</span><br /><br />A continuación mostraré un ejemplo de una interfaz fluida anidada utilizando expresiones lambda en algunos de sus métodos. A partir de la clase <code>Garaje</code> iremos profundizando paso por paso hasta completar la interfaz: <script src="https://gist.github.com/jesuscampos/b94813a6adf8e8b20fcf1029b1a401d2.js"></script>Los métodos que forman parte de la interfaz fluida se identifican rápidamente porque todos ellos retornan el propio objeto (<code>this</code>). Veamos uno a uno: <br /><ul><li>El método <code>MaximaCapacidad</code> simplemente establece un número entero.</li><li>El método <code>ConfiguraCoche</code> acepta un delegado de tipo <code>Action</code> con dos parámetros de entrada. Esto permite al consumidor pasarnos un delegado en el que podrá hacer uso de un parámetro de tipo <code>Coche</code> y otro de tipo <code>Perfil</code>. Cuando este método sea llamado, invocaremos el Action con los parámetros que necesita.</li><li>El método <code>ConfiguraMoto</code> y <code>ConfiguraBici</code> también aceptan un delegado pero esta vez con un sólo parámetro de entrada. Cada uno de ellos acepta el propio objeto que se pretende configurar.</li></ul>Esta interfaz permite un código en el consumidor como el siguiente: <script src="https://gist.github.com/jesuscampos/df16577c24c98d10fe02bafcd4e6b542.js"></script>El objeto <code>garaje</code> instanciado permite encadenar los métodos de la interfaz. Los métodos que aceptan delegados abren un nuevo nivel en la interfaz donde el contexto es trasladado a cada elemento que estamos configurando. Por ejemplo, entre los corchetes { } de la expresión lambda del método <code>ConfiguraCoche</code> podremos empezar a parametrizar el objeto <code>coche</code>. En este caso nos proporciona también el objeto <code>Perfil</code> que podremos utilizar (o no) según nos convenga. <br />Para continuar veamos ahora la interfaz del objeto <code>Coche</code>: <script src="https://gist.github.com/jesuscampos/307eae06a40f36339e4fbee0b36659d0.js"></script>Si analizamos los métodos que aceptan delegados tenemos: <br /><ul><li>El método <code>ConfiguraMotor</code> acepta un <code>Action</code> con un parámetro de entrada del propio objeto <code>Motor</code> que estamos configurando. En este caso se instancia un objeto <code>MotorCoche</code> que es una extensión del objeto <code>Motor</code>.</li><li>El método <code>Ruedas</code> también acepta un <code>Action</code> con un parámetro de tipo <code>Ruedas</code>. En este caso se trata de un listado de elementos de tipo <code>Rueda</code>.</li><li>El método <code>FuncionConsumo</code> acepta un delegado de tipo <code>Func</code>. En este caso en vez de invocarlo inmediatamente lo almacena para usarlo como función de cálculo cada vez que se invoque el método&nbsp;<code>CalculaConsumo</code>. El delegado se convierte así en parte de la parametrización del objeto, solo que en lugar de almacenar un valor lo que hace es almacenar un comportamiento.</li></ul>Gracias a esta nueva interfaz podríamos ampliar nuestra configuración de la siguiente forma: <br /><script src="https://gist.github.com/jesuscampos/50e83eed7a124bb593be3da9bdf119bc.js"></script>Esta técnica permite acceder desde un contexto de nivel inferior a las variables de contextos de niveles superiores. Así por ejemplo, si necesitamos hacer uso de la variable <code>perfil</code> proporcionada en el contexto de <code>ConfigurarCoche</code> desde dentro del contexto de <code>ConfigurarMotor</code> la podemos utilizar sin problemas. <br /><br />En todos los métodos con delegados del ejemplo anterior se han invocado los delegados recibidos en el mismo momento en que se han recibido. Podría darse el caso que nos interesase ir almacenando todos los delegados en la clase e invocar todos ellos en un lote mediante una única llamada de inicialización al terminar de parametrizar los objetos. <br />Veamos algunos ejemplos de frameworks que utilizan interfaces fluidas con expresiones lambdas. <br /><h3>Swagger</h3>Como ejemplo de framework que utiliza una interfaz fluida tenemos <a href="https://swagger.io/">Swagger </a>. Este framework permite documentar una Web API de manera muy eficiente. Para configurar esta herramienta dispone de una interfaz fluida con una técnica similar a la que hemos utilizado en el ejemplo anterior. Se trata de una interfaz diseñada para trabajar con expresiones lambda y que además dispone de varios niveles de complejidad: <br /><script src="https://gist.github.com/jesuscampos/7dbd7d81f1eba544e55e8b75ce823b3f.js"></script>En el ejemplo se puede apreciar los distintos niveles de complejidad de la interfaz y los distintos métodos que expone cada nivel. Algunos de ellos son métodos con parámetros delegados. Cabe destacar que el código mostrado no es mas que una pequeña muestra de la cantidad de métodos y niveles que dispone esta interfaz para su configuración. <br /><h3>Linq</h3>Los métodos de extensión para el objeto <code>IEnumerable</code> de la librería Linq del Framework de .Net es un claro ejemplo de lo expresiva que resulta la manipulación de elementos utilizando el estilo de la interfaz fluida con expresiones lambda. <script src="https://gist.github.com/jesuscampos/586b037db7df511c24946468fbc5e99d.js"></script>En el ejemplo se puede interpretar fácilmente el proceso llevado a cabo en cada paso: <br /><ul><li>Como entrada utiliza el objeto personas que es de tipo <code>IEnumerable</code>&nbsp;que representa una colección de objetos de tipo <code>Persona</code>. Podría tratarse de cualquier colección que implemente esta interfaz.</li><li>El método <code>Where</code> filtra todas las personas de la colección cuyo apellido empieza por la letra "A". Este método a su vez devuelve otro objeto <code>IEnumerable</code> también con elementos de tipo <code>Persona</code>.</li><li>El método <code>OrderBy</code> ordena este resultado por la edad. Este método también devuelve un objeto <code>IEnumerable</code> con elementos de tipo <code>Persona</code>.</li><li>Finalmente, el método <code>Select</code>, aunque devuelve también una colección <code>IEnumerable</code>, esta vez no es de elementos <code>Persona</code>, se han proyectado hacia elementos <code>string</code> mediante la función proporcionada. El método <code>Select</code> tiene la capacidad de convertir (proyectar) cada elemento en otro según la función que le pasamos como parámetro. En nuestro caso la función proyecta cada elemento de tipo <code>Persona</code> en un <code>string</code> que representa la concatenación del nombre y el apellido.</li></ul>Como dije al principio de este post el encadenamiento se produce porque cada método de un objeto devuelve el propio objeto <b>o al menos del mismo tipo</b>. Un cambio del tipo devuelto rompería la cadena. En este caso, cada método opera sobre los elementos de la colección anterior usando para ello su condición de <code>IEnumerable</code> y devuelve <b>un nuevo objeto</b> <code>IEnumerable</code> con los elementos del resultado, que no tienen por qué ser del mismo tipo que los elementos de origen. <br /><misnotas>La proyección no está produciendo un cambio del tipo, que en este caso siempre es IEnumerable, sino que cambia el tipo de sus elementos.</misnotas>En el ejemplo siguiente, como no hay proyección, obtendremos un resultado idéntico a la colección inicial. Sin embargo, se ve claramente que no es lo mismo filtrar todas las personas cuyo apellido empiece por "A" y quedarte con los 10 primeros, que quedarte con los 10 primeros y filtrar de esos 10 sólo los que empiecen por "A": <script src="https://gist.github.com/jesuscampos/a6f63f938786425474c9f9e40cf8a8b1.js"></script><br /><h2>Arboles de expresión y reflexión estática</h2>Queda en el tintero el diseño de interfaces fluidas con árboles de expresión. Este tipo de parámetros nos permite todavía más flexibilidad que la de un simple delegado. Además de la potencia de los delegados nos ofrecen la capacidad de disponer de la expresión sin compilar. De esta forma tenemos la expresión almacenada como una estructura de árbol en la que los nodos representan los operadores y las hojas a los operandos. <br />Se trata de un tema demasiado extenso para exponerlo dentro de las interfaces fluidas y he decidido publicarlo en dos futuros posts donde se explicarán más detalladamente el uso de estos árboles y la reflexión estática donde las interfaces fluidas pueden aprovechar ciertas características extra. <br />Como adelanto dejo aquí un enlace a los frameworks&nbsp;<a href="https://www.hibernatingrhinos.com/oss/rhino-mocks">Rhino Mocks</a>&nbsp; y <a href="https://github.com/Moq/moq4/wiki/Quickstart">Moq </a>que hacen uso de la reflexión estática con expresiones de árbol para ofrecer una interfaz fluida al consumidor. Se trata de frameworks opensource para .Net que ayudan a crear implementaciones mock para realizar tests.