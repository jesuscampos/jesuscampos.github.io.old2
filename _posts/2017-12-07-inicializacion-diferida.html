---
layout: post
title: Inicialización diferida
date: '2017-12-07T08:22:00.001-08:00'
author: Jesús
tags:
- DI
- Inicializacion diferida
- Programación Orientada a Objetos
- Unity
- Entity Framework
- C#
- Lazy initialization
- lock
- Activator
- IoC
- Thread safe
- POO
- ORM
- Lazy
- Objeto
- Singleton
- Instancia
modified_time: '2018-10-20T04:06:57.739-07:00'
blogger_id: tag:blogger.com,1999:blog-3773544929012013646.post-290458671712162137
blogger_orig_url: https://codigo418.blogspot.com/2017/12/inicializacion-diferida.html
---

<h1>Introducción</h1>La inicialización o carga diferida (lazy initialization) nos permite posponer la creación de un objeto hasta su primer uso. Esto nos ayuda a aumentar el rendimiento de nuestras aplicaciones cuando tenemos objetos muy pesados que no son necesarios de forma inmediata e incluso puede que no se lleguen a usar nunca. También nos permite mejorar el inicio de un programa priorizando la carga instantánea de los objetos necesarios al inicio y posponiendo la carga de otros objetos pesados después.<br /><br />Una forma muy simple de realizar una inicialización diferida sobre una propiedad es la siguiente: <script src="https://gist.github.com/jesuscampos/2f82da466446d1b9ee4900011aa8b7a3.js"></script>La variable de respaldo <code>_pedidos</code> se mantendrá sin inicializar hasta que accedamos a la propiedad <code>Pedidos</code> por primera vez. En ese momento se creará la instancia llamando al constructor. Las siguientes veces que accedamos a la propiedad obtendremos la misma instancia. <br /><br />El problema que tenemos con este código es que no implementa <a href="https://es.wikipedia.org/wiki/Seguridad_en_hilos"><b>seguridad en hilos</b></a> (no es thread safe). Si estamos seguros que sólo vamos a acceder al objeto desde un mismo hilo podemos utilizar sin problemas este método. En caso contrario nos podríamos encontrar con varios accesos concurrentes que nos crearían varias instancias. <br /><br />Para evitarlo tendríamos que realizar un bloqueo que nos garantizase que no se vayan a crear varias instancias desde distintos hilos. <br /><h1>Objeto Lazy&lt;T&gt;</h1>Desde el Framework 4.0 de .Net contamos con un objeto muy útil para la inicialización diferida. Se trata del objeto <code>Lazy&lt;T&gt;</code>. Simplificando se trata de un objeto que envuelve una instancia de un objeto de tipo <code>T</code> en su propieadad <code>Value</code>. Inicialmente la instancia será nula, y cuando se acceda a ella por primera vez, se creará la instancia del objeto en memoria. La forma en que se cree la instancia del objeto depende de cómo hayamos creado la instancia de nuestro objeto <code>Lazy</code>: <br /><ul><li>Si nuestro objeto cuenta con un constructor por defecto sin parámetros podemos crear la instancia del objeto <code>Lazy</code> de forma sencilla:</li><script src="https://gist.github.com/jesuscampos/e44b079076fc301e2e2ce99fd479ed0f.js"></script>En este caso Lazy creará la instancia mediante el uso del método <code>Activator.CreateInstance</code>. <li>Si nuestro objeto requiere de parámetros para su construcción o queremos utilizar nuestro propio método Factory deberemos usar la sobrecarga que acepta un delegado de tipo <code>Func&lt;T&gt;</code>:</li><script src="https://gist.github.com/jesuscampos/53cf18d1d9d286857b91c3890d2faa3f.js"></script>Para este segundo caso, Lazy invocará el delegado suministrado para crear la instancia. </ul>En ambos casos hemos creado la instancia del objeto <code>Lazy</code> que actuará de contenedor de nuestro objeto, pero el objeto todavía no se ha instanciado. Para instanciar el objeto debemos acceder a él mediante la propiedad <code>Value</code> del objeto <code>Lazy</code>. Al acceder a esta propiedad por primera vez se creará la instancia de nuestro objeto y se devolverá. A partir de entonces, cada vez que se acceda a esta propiedad se devolverá esta misma instancia. <br /><br />Veamos ahora un ejemplo de incialización diferida de una propiedad con el objeto <code>Lazy</code>. La clase <code>Cliente</code> inicializa en su constructor un objeto <code>Lazy</code> para que se encargue de diferir la inicialización de sus <code>Pedidos</code>: <script src="https://gist.github.com/jesuscampos/aad042409c2a53d6c0fb2bb5b56a5ffe.js"></script>Al acceder a la propiedad <code>MisPedidos</code>, como internamente se lee la propiedad <code>Value</code> de nuestro objeto <code>Lazy</code>, se desencadenará la inicialización de la instancia diferida: <script src="https://gist.github.com/jesuscampos/3dd16990cb6ce7b9feb2a5620cb66a56.js"></script>Si el contexto donde se use la instancia de <code>Cliente</code> no necesita acceder a los pedidos del cliente no se inicializarán nunca. Si estos pedidos tienen que ser obtenidos de una base de datos o un servicio externo estaremos ahorrando una carga de datos remota y además estaremos contribuyendo a un ahorro de memoria. <br /><br />La mejora que obtenemos con respecto al primer método es que el objeto <code>Lazy</code> implementa <b>seguridad en hilos</b> por defecto. Si utilizamos cualquiera de las dos sobrecargas anteriores para crearlo, garantizamos que son <b>"thread-safe"</b>, lo cual significa que varios consumidores del objeto podrían concurrir a solicitar la instancia pero sólo el primero de ellos crearía realmente la instancia, y los siguientes usarían esa misma instancia. <br /><h3>¿Y si no queremos seguridad en hilos?</h3>Se pueden usar otras sobrecargas del constructor del objeto <code>Lazy</code> donde podemos establecer el parámetro <code>isThreadSafe</code> en false para mejorar el rendimiento en caso de que no utilicemos varios subprocesos. No hay que confundir entre la seguridad en la inicialización de la instancia con el posterior uso que se le de a esa instancia. Según msdn Microsoft: <misnotas>Haciendo el objeto Lazy&lt;T&gt; <b>seguro para subprocesos</b> no protege al objeto inicializado en diferido. Si hay multiples hilos que pueden acceder al objeto inicializado en diferido, debes hacer sus propiedades y métodos <b>seguros para subprocesos</b>. </misnotas><h1>Aplicado al patrón Singleton</h1>El <a href="https://es.wikipedia.org/wiki/Singleton">patrón Singleton</a> restringe la instanciación de una clase a un sólo objeto y ofrece un único punto de acceso a esta instancia. La versión más simple del patrón singleton sería la siguiente: <script src="https://gist.github.com/jesuscampos/476350689349651358e767b8bdcfbd4f.js"></script>Se basa en restringir el acceso a la instancia únicamente por medio de su propiedad pública Instance, la cual crea la instancia la primera vez y devuelve la misma en sucesivos accesos. Al hacer privado el constructor impedimos que exista otra forma de crear la instancia. Otra característica de una clase Singleton sería la instanciación en diferido ya que mientras no se inicialice la clase no se creará la instancia del objeto. <br /><br />Aquí nos volvemos a encontrar con el problema de entornos multihilo, ya que podríamos tener dos hilos en ejecución que evaluasen la condición <code>instance == null</code> como true. En este caso, ambos hilos crearían una instancia, violando así el principio del patrón Singleton que restringe a una única instancia. <br /><br />Esto nos llevaría a utilizar técnicas de bloqueo usando un bloque <code>lock</code> cada vez que accedamos a la instancia, lo que podría repercutir en el rendimiento de nuestra aplicación. También podríamos recurrir al uso de constructores estáticos para forzar que sólo se invoque una vez. Esto simplificaría bastante la lógica de bloqueos pero bastaría con tener otro miembro estático para perder la garantía de que la instancia se crea de forma diferida. Para profundizar más sobre los distintos tipos de Singleton posibles y sus pros y contras aconsejo leer este magnífico artículo de <a href="http://csharpindepth.com/Articles/General/Singleton.aspx">http://csharpindepth.com/</a>. <br /><br />Una solución muy elegante que nos asegura la seguridad en subprocesos y la inicialización en diferido es utilizando de nuevo el objeto <code>Lazy</code>. El Singleton resultante es muy simple y tiene muy buen rendimiento: <script src="https://gist.github.com/jesuscampos/ef930487e4fa471039a5dbc4c7345e72.js"></script><br /><h1>Inicialización diferida en los sistemas ORM</h1>En sistemas <a href="https://es.wikipedia.org/wiki/Mapeo_objeto-relacional">ORMs</a> como <b>Entity Framework</b> o <b>Hibernate</b> se puede utilizar la carga diferida en sus propiedades de navegación. De esta manera podemos trabajar con una entidad "padre" sin necesidad de cargar en memoria todos sus miembros de otras entidades o de colecciones de entidades "hijas" mientras no sean requeridas. Si en algún momento accedemos a uno de estos miembros se inicializarán , se realizará la consulta a la base de datos y se mapearán sus propiedades con los datos recibidos. Para el caso de las colecciones hay que destacar que no es la creación del objeto colección el que se pospone, ya que se crea en el propio constructor de la clase "padre", sino los elementos que forman parte de la colección. En definitiva es en los elementos donde reside toda la carga de memoria en una colección.<br /><br />No sólo mejoramos el rendimiento en términos de procesamiento y de memoria de la aplicación sino que mejoramos el tráfico entre la aplicación y la base de datos e incluso haremos que las consultas ejecutadas en la base de datos sean más ligeras ya que eliminaremos los joins con otras tablas. <br /><br />Imaginemos que queremos obtener de la base de datos el nombre y la dirección de un cliente. Aunque la entidad de un cliente tenga una propiedad de navegación a una colección de sus pedidos no nos interesa obtenerlos porque nos penalizaría su carga. Por esta razón, los ORMs suelen tener carga en diferido automática por defecto en sus propiedades de navegación. <br /><br />Aunque si nos interesa podemos hacer que la carga sea instantánea en lugar de diferida. En Entity Framework por ejemplo esto se hace mediante el método <code>Include</code> del contexto y pasando un <code>string</code> que represente la relación que queremos cargar. <br /><br />También podemos desactivarla y forzar una carga explícita, es decir, que tengamos que cargarla nosotros mediante una llamada explícita. <br /><br />A continuación tenemos los tres ejemplos de cargas posibles en Entity Framework: <br /><ol><li><b>Carga diferida</b>. Con la carga diferida activada, primero cargaremos los clientes pero dejaremos la propiedad de navegación de sus pedidos vacía. Sólo cuando accedamos a sus pedidos será cuando se realice la carga.</li><li><b>Carga explícita</b>. Aun con la carga diferida desactivada podremos realizar una carga en diferido, eso sí, lo tendremos que hacer de forma explícita. En el ejemplo vemos dos tipos de carga explícita sobre propiedades de navegación de una entidad. La primera de ellas se ha utilizado el método <code>Reference</code> por tratarse de una entidad simple. Para la segunda propiedad de navegación se ha utilizado el método <code>Collection</code> por tratarse de una colección de entidades.</li><li><b>Carga instantánea</b>. Especificando el "path" de nuestra relación estaremos realizando en una misma carga todas las entidades implicadas en la relación. En el ejemplo estamos realizando la carga de un cliente, todos sus pedidos y los detalles de los mismos.</li></ol><script src="https://gist.github.com/jesuscampos/d81eb964ce64648f3ed2f9d2f74bf403.js"></script> <br /><h1>Resolución de instancias en diferido con Unity</h1>Aunque estemos utilizando un <a href="https://es.wikipedia.org/wiki/Inyecci%C3%B3n_de_dependencias">contenedor DI</a> como <a href="https://msdn.microsoft.com/es-es/library/ff647202.aspx">Unity</a> podemos hacer que nuestras instancias se creen también en diferido. El registro de nuestro tipo en el contenedor lo haremos como siempre. En el momento que queramos resolver el tipo utilizaremos el objeto <code>Lazy&lt;T&gt;</code>, donde <code>T</code> será el tipo que hemos registrado. <script src="https://gist.github.com/jesuscampos/103130b9267fac200d7b5eb5c7847d1b.js"></script>