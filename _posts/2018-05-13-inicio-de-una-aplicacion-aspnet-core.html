---
layout: post
title: Inicio de una aplicación ASP.NET Core
date: '2018-05-13T01:35:00.000-07:00'
author: Jesús
tags:
- ASP.NET
- Inyección de dependencias
- ASP.NET Core
- Startup
- C#
- Interfaz fluida
- Middleware
- Net Core
modified_time: '2018-10-20T04:23:36.372-07:00'
thumbnail: https://4.bp.blogspot.com/-4uaN3PeeOxU/WvdPuApbL3I/AAAAAAAAJKI/KjBgHWgm1x4ftCwVxjp-WR4VzUUfC4a1QCLcBGAs/s72-c/Middleware.png
blogger_id: tag:blogger.com,1999:blog-3773544929012013646.post-3376339620840853900
blogger_orig_url: https://codigo418.blogspot.com/2018/05/inicio-de-una-aplicacion-aspnet-core.html
---

<h2>Introducción</h2><b>ASP.NET Core</b> es un framework para desarrollar aplicaciones web <b>multiplatarforma</b>, de <b>código abierto</b> y se encuentra disponible en <a href="https://github.com/aspnet/home">GitHub</a>. El hecho de que sea multiplataforma significa que nuestra aplicación <b>no puede estar acoplada a un servidor concreto</b>. Aparte de que nuestra aplicación sea multiplataforma tendremos otros beneficios adicionales:        <ul><li>No necesitamos instalar un Framework .NET para que se ejecute. Todos las bibliotecas necesarias forman parte de nuestra entrega.</li><li>Puede usarse Visual Studio Code para desarrollar las aplicaciones el cual es libre, ligero y está disponible para todas las platarformas.</li><li>Es muy ligero en comparación con <b>ASP.NET</b>. Las comparaciones entre ambos frameworks son bastante significativas, tanto en términos de memoria consumida, como de espacio en disco y lo más importante, las peticiones que es capaz de servir por segundo.</li></ul> <h2>Desacople servidor-aplicación</h2>En un primer paso, <b>ASP.NET</b> introdujo una evolución implementando la especificación <a href="http://owin.org/">OWIN</a> con su proyecto <a href="https://github.com/aspnet/AspNetKatana/">Katana</a>. De esta forma podemos crear una aplicación web sin usar la biblioteca System.Web y así eliminar la dependencia de IIS de nuestra aplicación. </br></br>Inicialmente bautizado como <b>ASP.NET vNext</b>, <b>ASP.NET Core</b> da continuidad a esta separación servidor-aplicación convirtiéndose en el sucesor de Katana, pero aún va mucho más allá, nos proporciona un nuevo CLR, cambia el sistema de proyectos, integra un contenedor para la inyección de dependencias, nos facilita la personalización de la canalización (pipeline) mediante middleware y un largo etcétera. </br></br>Estos aspectos introducen diferencias significativas en el ciclo de vida de las aplicaciones, empezando por el punto de entrada.  <h2>Punto de entrada</h2>En una aplicación <b>ASP.NET</b> el punto de entrada es el archivo <b>Global.asax</b>. Aquí es donde se controlan tareas como la configuración de rutas, el registro de filtros y el registro de las áreas. </br></br>La primera diferencia que nos encontramos al crear nuestra primera aplicación <b>ASP.NET Core</b> es que se trata de una <b>aplicación de consola</b>. Una aplicación con una clase <code>Program</code> y con su propio punto de entrada mediante un método <code>Main</code>.  <h3>WebHost</h3>Lo primero que debemos hacer en una aplicación <b>ASP.NET Core</b> es configurar e iniciar un objeto <code>WebHost</code> que hará tanto de aplicación como de Host HTTP. Nuestra implementación de <code>WebHost</code> escuchará peticiones HTTP y las introducirá en nuestra aplicación en forma de un objeto <code>HttpContext</code> con toda la información de la petición. La inicialización de este Host la haremos en el punto de entrada: método <code>Main</code> de la clase <code>Program</code>. </br></br><b>ASP.NET Core</b> incluye dos implementaciones de servidor: <b>Kestrel</b> y <b>HTTP.sys</b>. La primera de ellas es un servidor HTTP multiplataforma y la segunda es sólo para Windows. <b>Kestrel</b> es el servidor que está incluido en las plantillas para proyectos <b>ASP.NET Core</b>. </br></br>De la versión 1.0 a la versión 2.0 de <b>ASP.NET Core</b> se ha simplificado la configuración del servidor <b>Kestrel</b> introduciendo el método <code>CreateDefaultBuilder</code> que encapsula la configuración básica de este servidor. Invocando este método se configura un Host <b>Kestrel</b> con un proxy inverso <b>IIS</b> de frontal. Si queremos utilizar otro tipo de Host o precisamos de otras características personalizadas deberemos configurarlo de forma manual.  <script src="https://gist.github.com/jesuscampos/dfc76e8aaf5d6d8aefc5ea130d229502.js"></script> En el ejemplo vemos como se llama al método <code>BuildWebHost</code> para solicitar una implementación de <code>WebHost</code>. Una vez obtenida esta implementación se inciará el Host llamando al método <code>Run</code>.</br></br> Antes, el método <code>BuildWebHost</code> habrá llamado al método <code>CreateDefaultBuilder</code> que devuelve un objeto <b>builder</b> <code>IWebHostBuilder</code>, el cual se utiliza como ayudante para configurar el Host haciendo uso de una <a href="http://codigo418.blogspot.com.es/2017/12/interfaces-fluidas.html">interfaz fluida</a> donde podemos encadenar métodos de configuración sobre nuestro objeto <b>builder</b>. </br></br>Usamos esta interfaz fluida para decirle a nuestro Host que clase queremos que utilice como <b>Startup</b>. La clase <b>Startup</b> configura la canalización (pipeline) y las dependencias de nuestra aplicación. Para ello llamamos al método de extensión <code>UseStartup&lt;T&gt;</code> donde <code>T</code> es el tipo que queremos usar como <b>Startup</b>. Este tipo no es necesario que implemente ninguna interfaz ni que herede de ningún otro tipo. El <code>WebHost</code> se encargará de instanciarla e invocar sus métodos de configuración al inicio de la aplicación. </br></br>Para finalizar llamamos al método <code>Build</code> de nuestro <b>builder</b> para obtener el objeto <code>WebHost</code> que se solicitó desde el método <code>Main</code>. Es aquí donde se inicia el Host mediante el método <code>Run</code>. <misnotas>El objeto <b>WebHostBuilder</b>, mediante reflexión, se encarga de convertir nuestra clase <b>Startup </b>a una implementación de <b>IStartup </b>usando una convención de nombres en lugar de forzar a que se implemente una interfaz o se herede de una superclase. Este enfoque ha sido arrastrado de su predecesor <b>OWIN/Katana</b>. No obstante es posible implementar esta interfaz e incluso heredar de la clase abstracta <b>StartupBase</b>. Puede ser interesante usar la interfaz en lugar de la convención con el fin de "moquear" nuestro <b>Startup </b>para diseñar nuestros tests. </misnotas> <h2>Startup</h2>Aquí es donde realmente empieza la lógica de nuestra aplicación. Hasta ahora nos habíamos limitado a configurar y poner en marcha nuestro Host. Esta lógica será iniciada precisamente por nuestro Host antes de comenzar a despachar peticiones HTTP. Primero instanciará un objeto <b>Startup</b> y posteriormente llamará a sus métodos de configuración por este orden: <code>ConfigServices</code> y <code>Config</code>, siendo el primero de ellos opcional. Una vez llamados ambos métodos se entiende que la aplicación está lista para empezar a servir.  <h3>Instanciación de Startup</h3>El Host registra algunos servicios en el contenedor de dependencias que pueden ser utilizados mediante inyección en el constructor de nuestro <b>Startup</b>. Basta con añadir estos tipos como parámetros a nuestro constructor y el Host se encargará de resolver estas instancias y de inyectarlas. Uno de estos servicios es <code>IHostingEnvironment</code>, que proporciona información sobre el entorno de hospedaje web de la aplicación. </br></br>El método <code>CreateDefaultBuilder</code> que vimos en un apartado anterior, además de configurar un Host Kestrel básico, también registra en el contenedor una instancia <code>IConfiguration</code> con la configuración establecida en los archivos <b>appSettings.json</b> o <b>appsettings.{Environment}.json</b>. Si no usamos el método <code>CreateDefaultBuilder</code> deberemos registrar en el contendor nuestra propia instancia de configuración de forma manual en el <b>Startup</b>:  <script src="https://gist.github.com/jesuscampos/c339330c23c04c05ec1fe0f7723055ed.js"></script> Además, también podemos añadir nuestras propias dependencias cuando configuramos el Host en la clase <code>Program</code>, de esta manera pueden ser inyectadas en el constructor de la clase <code>Startup</code>: <script src="https://gist.github.com/jesuscampos/60ff60bea7b136dde96eecc9d9f392eb.js"></script>En el ejemplo hemos añadido una dependencia de tipo <code>IMyClass</code> al contenedor para que el <code>WebHost</code> sea capaz de resolverla y proporcionarnos una instancia en el constructor: <script src="https://gist.github.com/jesuscampos/ba7836acc56783756c185935938b7e89.js"></script> <h3>Método ConfigureServices</h3>Este método nos permite registrar servicios para que estén disponibles en el método <code>Configure</code> y en el resto de la aplicación. Para ello contamos con el parámetro <code>IServiceCollection</code>. Este parámetro es un contenedor de dependencias en el que podremos registrar dependencias de forma tradicional usando los métodos simples <code>AddScoped</code>, <code>AddTransient</code> y <code>AddSingleton</code>, dependiendo del ciclo de vida deseado, o también, mediante métodos de extensión del tipo <code>Add[servicio]</code> si tenemos algún registro más complejo que requiera de un método aparte.  <script src="https://gist.github.com/jesuscampos/c758e44e8849ea5559b14a42e830eecd.js"></script> Aunque muchas veces los métodos de extensión del tipo <code>IServiceCollection</code> devuelven el mismo objeto <code>IServiceCollection</code> para permitir encadenar metodos del tipo <code>Add[Servicio]</code>, a veces también pueden devolver objetos <b>builder</b> que permiten encadenar configuraciones más complejas usando una interfaz fluida. Otras veces estos métodos aceptan parámetros de opciones del tipo <code>Action&lt;MyServiceOptions&gt;</code> donde el objeto <code>MyServiceOptions</code> expone propiedades para poder ser utilizadas en expresiones lambda enriqueciendo la interfaz fluida disponible:  <script src="https://gist.github.com/jesuscampos/843811de719b5d9ec6956331258656c4.js"></script> <h3>Método Configure</h3> <h5>Middleware</h5>Los componentes que forman la canalización (pipeline) por la que viaja cada petición HTTP se denominan <b>middleware</b>. Cada uno de estos componentes recibe la solicitud del anterior y es responsable de continuar el flujo hacia el siguiente componente o de cortocircuitar el flujo terminando la canalización e iniciando el camino de vuelta. Tiene la posibilidad de ejecutar su propia lógica tanto antes de invocar al siguiente componente como después cuando regrese de vuelta: </br></br><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-4uaN3PeeOxU/WvdPuApbL3I/AAAAAAAAJKI/KjBgHWgm1x4ftCwVxjp-WR4VzUUfC4a1QCLcBGAs/s1600/Middleware.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://4.bp.blogspot.com/-4uaN3PeeOxU/WvdPuApbL3I/AAAAAAAAJKI/KjBgHWgm1x4ftCwVxjp-WR4VzUUfC4a1QCLcBGAs/s1600/Middleware.png" data-original-width="408" data-original-height="202" /></a></div> </br>En el método <code>Configure</code> especificaremos el <b>middleware</b> que queramos usar en nuestra aplicación web. Para ello se utilizará una interfaz fluida sobre el objeto <code>IApplicationBuilder</code> muy similar a la utilizada en el punto anterior, solo que en este caso los métodos se denominan <code>Use[Middleware]</code>. </br></br>El orden en el que se añaden los componentes es muy importante puesto que será el mismo orden en el que se invocarán en cada petición. También existe una convención de nombres <code>Run[Middleware]</code> para indicar que un componente es el último por lo que se inicia el camino de vuelta inmediatamente después.  </br></br>Existe una última convención no muy utilizida <code>Map[Middleware]</code> que sirve para trabajar con distintas ramas en la canalización. </br></br>Además del propio objeto <code>IApplicationBuilder</code> podemos especificar como parámetro del método cualquier servicio que hayamos añadido previamente al contenedor de dependencias.  <script src="https://gist.github.com/jesuscampos/4958552f2898120e44177201ca25d509.js"></script> 