---
layout: post
title: Programación asíncrona con async/await en .Net
date: '2018-10-14T10:58:00.001-07:00'
author: Jesús
tags:
- await
- Asíncrono
- escalabilidad
- programación asíncrona
- C#
- ASP.NET
- async
- cpu-bound
- thread pool
- awaitable
- Task
- i/o-bound
- responsividad
modified_time: '2018-10-14T10:58:07.819-07:00'
blogger_id: tag:blogger.com,1999:blog-3773544929012013646.post-5994427123746369514
blogger_orig_url: https://codigo418.blogspot.com/2018/10/programacion-asincrona-con-asyncawait.html
---

<h1>Introducción</h1>A partir de la versión 4.5 de .Net framework se ha simplificado de forma considerable la forma en que podemos trabajar con código asíncrono. Con los anteriores frameworks, si queríamos contar con los beneficios de una programación asíncrona nos veíamos obligados a lidiar con una gran complejidad en nuestro código. Esto nos hacía evitar su uso en lo posible a pesar de perder esta importante característica.<br /><br /><a href="https://blog.stephencleary.com/">Stephen Cleary</a>, un MVP especializado en concurrencia define la programación asíncrona como: <misnotas>  Una forma de concurrencia que utiliza futuros o "callbacks" para evitar hilos innecesarios.</misnotas>La programación moderna con <b>async</b> y <b>await</b> nos abstrae de la utilización de "callbacks" y nos permite utilizar futuros (Tasks) que se encargarán de notificar al llamante cuando el método asíncrono se complete. <h4>async y await</h4>Las palabras <b>async</b> y <b>await</b> son las palabras clave que .Net ha introducido en el lenguaje para que podamos implementar métodos asíncronos como si se tratase de métodos síncronos. El compilador realiza el trabajo difícil por nosotros permitiendo mantener una apariencia del código bastante simple. <br /><br />La palabra <b>async</b> simplemente marca a un método como asíncrono. A su vez, un método marcado como asíncrono estará habilitado para usar la palabra <b>await</b> y comenzar así una "espera". <br /><br />Aunque el método sea asíncrono se inicia como cualquier método síncrono. Todo cambia cuando se encuentra la palabra <b>await</b> seguido de un argumento de tipo <b>"awaitable"</b>. A partir de entonces comenzará a comportarse de forma asíncrona. <script src="https://gist.github.com/jesuscampos/966d8c4d8dfa95f4c90e0bfbd89955ea.js"></script> <misnotas>Aunque existen diversos tipos <b>awaitables</b> (incluso podemos implementar los nuestros), lo más habitual es usar el tipo tarea <b>Task</b> o <b>Task&lt;T&gt;</b> proporcionado por el framework.</misnotas> Dentro de nuestro método <code>DoWorkAsync</code> llamamos al método <code>GetStringAsync</code>, que también es un método asíncrono puesto que devuelve una Tarea (en concreto <code>Task&lt;string&gt;</code>) y en consecuencia se trata de un objeto "awaitable". Al ir precedido de <b>await</b> comenzará la parte asíncrona de nuestro método, es decir, se ha introducido una espera asíncrona. En consecuencia se detiene la ejecución del método <code>DoWorkAsync</code> y se devuelve una tarea <code>Task</code> sin completar. Esta tarea tendrá el compromiso de ejecutar el resto del método cuando se complete.  <misnotas>Si un await se encuentra con una tarea que ya está completada se comportará como una operación síncrona. </misnotas> <h4>Task vs Task&lt;T&gt;</h4>En el ejemplo anterior nuestro método asíncrono devolvía <code>Task</code>. Esto quiere decir que no se espera ningún valor de retorno. Usaremos <code>Task&lt;T&gt;</code> para métodos asíncronos que queramos que nuestro método asíncrono devuelva un valor. Veamos el mismo ejemplo anterior pero esta vez nuestro método asíncrono también tendrá el compromiso de generar un <code>string</code> cuando se complete. <script src="https://gist.github.com/jesuscampos/08527a95aa91f14687b37895dcccf68e.js"></script> <misnotas>Se debe evitar el uso de <b>async void</b> ya que void no es "awaitable". Recuerda que necesitas un "awaitable" para usarlo junto a <b>await</b>. Además, las posibles excepciones producidas en la operación asíncrona son capturadas dentro de la tarea. Cuando la tarea es "esperada" mediante <b>await </b> la excepción es relanzada y puede ser capturada mediante un <b>try / catch</b>. Si usamos <b>void</b> no tendremos oportunidad de capturar la excepción.</misnotas> <h4>Varios awaits dentro de un método asíncrono</h4>Es muy habitual encontrarnos varios awaits dentro de un método asíncrono. Cada vez que una operación asíncrona se haya completado, el flujo de ejecución retornará a terminar el código de nuestro método hasta que se termine o hasta que se encuentre otro await que inicie una nueva operación asíncrona. <script src="https://gist.github.com/jesuscampos/c26a9006fcf8b8ddf92958b2a33f39e1.js"></script> En el código anterior nuestro método detendrá la ejecución hasta en tres ocasiones devolviendo la tarea sin completar en cada una de ellas. Sólo al final podrá devolver la tarea completada con el resultado. <h4>async Task vs Task</h4>Se puede optar por devolver directamente una tarea completada en lugar de hacer un método asíncrono. Esto puede resultar útil cuando tenemos que implementar una interfaz con métodos <code>Task</code> pero nuestra implementación realmente no necesita dentro ningún <b>await</b>, es decir, no tiene por qué ser asíncrono. En ese caso podemos hacer los siguiente: <script src="https://gist.github.com/jesuscampos/e995ec5a7b6174236dd5d93d92c66bba.js"></script>El método <code>GetMagicNumber</code> implementado es bastante simple y no necesita ningún <b>await</b> para obtener el resultado. Podemos usar <code>Task.FromResult</code> que devuelve una tarea completada de forma síncrona con el valor que queramos. Así evitamos tener un método asíncrono haciéndolo mucho más eficiente y respetando la firma de nuestra interfaz. <h4>Beneficios que nos aporta la programación asíncrona</h4>Cuando usamos la programación asíncrona conseguiremos, o bien <b>responsividad</b> si se trata de una aplicación con una interfaz de usuario gráfica, o bien <b>escalabilidad</b> si se trata de una aplicación de servidor. En el primer caso evitaremos que la interfaz quede bloqueada e inservible para el usuario durante la operación. En el segundo caso permitiremos que el hilo que está gestionando la petición actual quede libre para ser reutilizado por otra petición entrante, aumentando significativamente la escalabilidad de nuestro servidor.<br /><br />Antes de continuar deberíamos distinguir dos tipos de operaciones "costosas": operaciones <b>CPU-Bound</b> o "vinculadas a CPU" y operaciones <b>I/O-Bound </b>o "vinculadas a entrada y salida".<br /><h2>Operaciones CPU-Bound vs I/O-Bound</h2><b>Las operaciones CPU-Bound</b> son operaciones donde se requiere que la CPU realice numerosos cálculos, como por ejemplo el cálculo de factoriales, algoritmos de compresión, encriptación, etc. Este tipo de operaciones <b>necesita forzosamente un hilo</b> para realizar la operación ya que para llevar a cabo la operación la CPU ejecuta código.<br /><br /> <b>Las operaciones I/O-Bound</b> son operaciones externas a la CPU donde delegamos a un subsistema de entrada o de salida una operación como por ejemplo acceso a disco, conexión a una base de datos, acceso a la red, etc. En este tipo de operaciones <b>no se requieren hilos </b>mientras se llevan a cabo. A diferencia del caso anterior nuestra CPU no ejecuta código durante la operación.<br /><br />Ambos tipos de operaciones pueden producir cuellos de botella debido al retardo producido y en ambos tipos podemos mejorar nuestras aplicaciones utilizando la programación asíncrona.<br /><br />Cuando el hilo de nuestra aplicación se encuentra con una operación demasiado larga vinculada a I/O podemos optar por esperar: <b>bloqueo</b>; o seguir con otra cosa mientras el proceso termina: <b>programación asíncrona</b>. En este caso el hilo que inició la operación es liberado para realizar otra operación. Una programación asíncrona nos permitirá obtener <b>responsividad</b> en el caso de que estemos en una aplicación de interfaz de usuario y <b>escalabilidad</b> si estamos en una aplicación de servidor. Para operaciones vinculadas a entrada y salida usaremos <b>async</b> y <b>await</b> tal y como se ha explicado anteriormente.  <br /><br />Sin embargo, para operaciones vinculadas a CPU deberemos tener presentes algunas consideraciones. En este caso no se trata de una operación asíncrona "pura", si no que necesitamos ejecutar código de forma síncrona. Eso sí, podemos aportar responsividad al delegar a otro hilo esta tarea liberando al hilo de nuestra interfaz. Para ello haremos uso del método <code>Task.Run()</code> que solicita un hilo del thread pool para que se encargue de ejecutar nuestra operación. <h4>Programación asíncrona con Task.Run para operaciones CPU-Bound</h4><div>En el caso de las operaciones vinculadas a la CPU podemos encontrarnos con un problema si nuestro hilo de ejecución es el hilo de una interfaz de usuario: <b>pérdida de la responsividad</b>.</div><div><br /></div><div>Necesitamos un hilo que se encargue de la operación, sí, pero no queremos que nuestro hilo principal de la interfaz de usuario se ponga a hacer trabajos pesados que produzcan un bloqueo de la interfaz desagradable para el usuario. Para evitarlo debemos utilizar <code>Task.Run</code> para ejecutar nuestro código de una forma asíncrona. <code>Task.Run</code> ejecutará nuestro código en un hilo del "thread pool" y liberará el hilo de la interfaz de usuario para evitar su bloqueo. Ambos hilos se ejecutarán de forma paralela.</div><script src="https://gist.github.com/jesuscampos/1007fb8aefd92fea4dff6a633f0007d3.js"></script><br /><div><code>Task.Run</code> devuelve una tarea que al esperarla (await) estaremos liberando el hilo de la interfaz de usuario. <br /><h4>Uso de Task.Run fuera de una interaz de usuario</h4>El uso de <code>Task.Run</code> fuera del contexto de una interfaz de usuario no tiene ningún beneficio, sólo producirá un descenso en el rendimiento. Si no tenemos la necesidad de "liberar" una interfaz de usuario lo mejor es que sea un único hilo quien gestione toda la operación de inicio a fin. Veamos un ejemplo correcto de una aplicación de servidor ASP.NET en la que llamamos a una operación vinculada a CPU desde un método de acción de un controlador: <script src="https://gist.github.com/jesuscampos/f2a64dd5f1fabc666d8adb3a02281086.js"></script>En este ejemplo la petición realiza todo el proceso de forma síncrona. Un único hilo es el que se encarga de todo el proceso. Sin embargo, veamos ahora un mal ejemplo en el que haremos uso de <code>Task.Run</code> en el mismo escenario.  <script src="https://gist.github.com/jesuscampos/a1dc83b50a91b6f4bc50ddfe8bdf394a.js"></script>Aunque el ejemplo funciona perfectamente se produce un intercambio de hilos innecesario reduciendo la escalabilidad de la aplicación. El hilo que inicia el método de acción es el hilo ASP.NET. Cuando se ejecuta <code>Task.Run</code> se está requiriendo un hilo extra a nuestro thread pool para que se encargue de la operación. A su vez, el hilo original es devuelto al thread pool para que pueda atender nuevas peticiones. Cuando la tarea termina, el hilo extra es devuelto al thread pool. Esta reducción del rendimiento es menos significativa cuanto mayor sea el tiempo empleado en la operación. </div><h4>Convención de firma Async para operaciones CPU-Bound</h4>Una mala práctica es "ocultar" tras un método con una firma del tipo MyMethodAsync un <code>Task.Run</code> que ejecuta un método vinculado a CPU. <script src="https://gist.github.com/jesuscampos/5a0ca1ddcc4c12d2f750537fe98b67ed.js"></script>El hecho de devolver una Task, al ser "awaitable", invitará al consumidor a usar una estructura async/await pensando que el método es realmente asíncrono cuando realmente no lo es. Aunque liberará el hilo actual, otro hilo se quedará efectuando una tarea de forma síncrona, algo que en la mayoría de casos puede no ser importante pero que en otros podría causar efectos no esperados para el desarrollador. Además, una aplicación ASP.NET, creyendo que está mejorando la escalabilidad de la aplicación al hacer uso de async y await, en realidad la estaría empeorando tal y como se ha explicado en el apartado anterior.<br /><br />Como resumen podríamos decir que se deberían dejar los métodos vinculados a CPU como síncronos (sobre todo en código que forme parte de bibliotecas reutilizables), y que los consumidores del método decidan si usar <code>Task.Run</code> en función del contexto en el que se encuentren. Una buena práctica es documentar el código de forma que indique que el método es CPU-Bound. <br /><br />En el ejemplo siguiente el método <code>DoWork</code> realiza una operación vinculada a la CPU. Un consumidor que quiera obtener responsividad en una aplicación de escritorio llamaría al método usando <code>Task.Run</code> para liberar la interfaz, sin embargo, una aplicación de servidor o de consola preferirá llamar al método de forma síncrona: <script src="https://gist.github.com/jesuscampos/9382b7fb549f9b213ea21ccd97bdfe72.js"></script>