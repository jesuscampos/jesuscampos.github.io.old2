---
layout: post
title: La importancia del encapsulamiento. Parte 1. Introducción.
date: '2017-10-15T13:03:00.000-07:00'
author: Jesús
tags:
- Programación Orientada a Objetos
- POO
- C#
- Propiedades
- Modificadores de acceso
- Encapsulamiento
modified_time: '2017-12-06T08:22:09.009-08:00'
blogger_id: tag:blogger.com,1999:blog-3773544929012013646.post-8323359391127670715
blogger_orig_url: https://codigo418.blogspot.com/2017/10/la-importancia-del-encapsulamiento.html
---

<h2>Introducción</h2><misnotas>En programación orientada a objetos el término encapsulamiento es utilizado indistintamente para describir dos conceptos diferentes pero a la vez relacionados entre sí: <br /></misnotas><br /><ol><li>Como mecanismo de restricción del acceso a componentes de un objeto;</li><li>Como construcción del lenguaje para facilitar el “empaquetado” del estado y el comportamiento.</li></ol>En este post el significado al que se hace referencia es al primero de ellos. La visibilidad o accesibilidad es el primer paradigma que nos encontramos al empezar a escribir nuestro código. Cuando comenzamos a escribir una clase, interfaz, enumerado o estructura, lo primero que hacemos es establecer su modificador de acceso, y si no lo hacemos, se establecerá el modificador por defecto. <script src="https://gist.github.com/jesuscampos/b961686d005cfc5ce33891daff930837.js"></script>Lo mismo ocurre cuando empezamos a escribir cada uno de sus miembros: variables de estado (campos) y métodos: lo primero de todo es escribir su modificador de acceso. <script src="https://gist.github.com/jesuscampos/e21369a7784b51f9f035a4f34f06da6a.js"></script>A menudo me encuentro con código sin tener en cuenta este aspecto: código demasiado “abierto” al exterior. Los errores más comunes que pueden llevarnos a una mala práctica de encapsulamiento son:<br /><ul><li>¿Para qué perder el tiempo? Hago todo público y así seguro que compila. Más adelante ya veré si me conviene cambiar el modificador.</li><li>¿Y si permito que se lea y escriba en todos mis campos? El código no se rompe y si más adelante necesito acceder ya lo tendré disponible.</li><li>¿Qué más da si este método se ve desde fuera o no? A nadie le molesta que haya un método más disponible. De todas formas no creo que sea de mucha utilidad a terceros y seguramente ni lo usen.</li><li>Está bien, intentaré no abusar del modificador public. Pero… ¿Y si establezco el modificador de todos mis miembros como protegidos? De este modo encapsulo hacia el exterior pero si extiendo la clase no tendré problemas para acceder a los miembros de la base. Al fin y al cabo es su legítimo heredero.</li></ul>Si sigues alguna de estas prácticas puede que no estés realizando bien el encapsulamiento de tu código. No sólo queremos código que funcione, sino que además sea mantenible y seguro.<br /><h2>Ventajas de encapsular</h2>El encapsulamiento de objetos oculta su interior protegiendo su integridad. Previene que desde fuera se pueda manipular el estado del objeto. Si no se restringe el acceso podría dejar al objeto en un estado inválido o inconsistente.<br />Otra ventaja del encapsulamiento es la reducción de la complejidad. Una clase debe tener una interfaz pública mínima para su manipulación. Si vamos a usar una clase en la que no se ha restringido de forma eficiente el acceso a sus miembros podemos encontrarnos con un exceso de funcionalidad irrelevante para nosotros, o peor aún, una puerta abierta a miembros que no debería acceder por riesgo a modificar el estado de la clase sin ningún criterio.<br /><h3>Controlando el alcance de nuestros cambios</h3>Una ventaja muy importante subyacente de un buen encapsulamiento es que mejora notablemente nuestra visión del alcance del cambio.<br />Cuando controlamos de forma eficientemente el encapsulamiento de nuestro código también estamos marcando los límites físicos a los que puede llegar ese código. De esta forma acotamos los “daños colaterales” de futuros cambios.<br />Por ejemplo, si hacemos un miembro público en una clase publica quiere decir que este miembro puede estar accesible para cualquiera dentro y fuera de nuestro ensamblado. Un cambio de nombre o eliminación de este miembro puede significar que se rompa el código de nuestro ensamblado, algo no muy grave ya que nos daríamos cuenta al compilar y podríamos corregirlo. Pero también podríamos estar rompiendo código de otros ensamblados que dependen del nuestro.<br />Esto representa un mayor problema porque a veces ni siquiera tenemos acceso a estos ensamblados. La forma correcta de proceder sería mantener esta propiedad “viva” aunque hayamos creado un código alternativo mejor que éste por el mero hecho de mantener la compatibilidad binaria. Podríamos marcar como obsoleto el miembro y esperar a una futura versión para romper esta compatibilidad binaria.<br /><h4>¿Y si este miembro no estuviera debidamente encapsulado?</h4>Imaginemos que este miembro, en realidad, sólo lo hemos utilizado en la propia clase y en dos extensiones de la propia clase, y además la clase podría haber sido internal ya que no se debería utilizar fuera del contexto de nuestro ensamblado. Hubiera sido suficiente un modificador protected para dar visibilidad sólo a la propia clase y a sus extensiones. De esta forma, cuando se deba realizar algún cambio sobre este miembro sabemos con certeza que:<br /><ul><li>no va a romper nada fuera de nuestro ensamblado;</li><li>podemos revisar fácilmente las dos clases que extienden de la nuestra para ver si afecta nuestro cambio de alguna manera.</li></ul>Un buen encapsulamiento nos simplifica mucho nuestra tarea y nos da seguridad a la hora de realizar un cambio.<br />La tranquilidad que da modificar o eliminar un miembro privado de una clase no tiene precio. Sabes que el cambio está afectando sólo a la clase que tienes delante.<br />Un programador que hace todo público nunca tendrá este tipo de control. El código es mucho menos mantenible y más propenso a errores.<br /><h2>¿Cómo deberíamos proceder?</h2>La regla que yo sigo para encapsular una clase es: asignar la mínima visibilidad posible a los miembros de nuestras clases, tanto campos como métodos. Y si un miembro tiene que ser accesible, deberemos pensar en qué forma y en qué nivel de acceso lo hacemos. Si más adelante necesito ampliar la accesibilidad de un miembro o de un tipo aumentaré su visibilidad hasta el nivel mínimo que cumpla con mis necesidades de acceso.<br /><br />A nivel de clase procedo de la misma forma: siempre internal y, sólo cuando lo necesito, lo cambio a public.<br /><br />En definitiva se trata de definir la “interfaz visible” de las clases y sus miembros para que sean accesibles desde otras clases que la usen o desde clases que la extiendan.<br />Estos son los modificadores utilizados en C# en orden de menor a mayor restricción:<br /><br /><table><tbody><tr><td width="37"></td><td width="185"><strong>Modificador</strong></td><td width="344"><strong>Accesible desde…</strong></td></tr><tr><td width="37"></td><td width="185">public</td><td width="344">Sin restricción</td></tr><tr><td width="37">&nbsp;<img alt="Signal Protected Symbol" id="1619219b-8f2a-427f-bfb8-b655a3ff9b02" src="https://i-msdn.sec.s-msft.com/dynimg/IC570692.jpeg" title="Signal Protected Symbol" /></td><td width="185">protected internal</td><td width="344">El propio ensamblado, la propia clase y sus extensiones</td></tr><tr><td width="37">&nbsp;<img alt="Signal Friend/Internal Symbol" id="3d372e22-4e0e-4492-8e9e-60270704927e" src="https://i-msdn.sec.s-msft.com/dynimg/IC570695.jpeg" title="Signal Friend/Internal Symbol" /></td><td width="185">internal</td><td width="344">El propio ensamblado y la propia clase</td></tr><tr><td width="37">&nbsp;<img alt="Signal Protected Symbol" id="1619219b-8f2a-427f-bfb8-b655a3ff9b02" src="https://i-msdn.sec.s-msft.com/dynimg/IC570692.jpeg" title="Signal Protected Symbol" /></td><td width="185">protected</td><td width="344">La propia clase y sus extensiones</td></tr><tr><td width="37">&nbsp;<img alt="Signal Private Symbol" id="f3ef11d7-353c-4db7-94d2-0244dc688839" src="https://i-msdn.sec.s-msft.com/dynimg/IC570693.jpeg" title="Signal Private Symbol" /></td><td width="185">private</td><td width="344">La propia clase</td></tr></tbody></table><br /><a href="https://codigo418.blogspot.com/2017/12/la-importancia-del-encapsulamiento.html">&gt;&gt; Ir a Parte 2. Un ejemplo de encapsulamiento en la vida real.</a>