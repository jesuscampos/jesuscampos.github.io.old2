---
layout: post
title: La importancia del encapsulamiento. Parte 3. Descriptores de acceso. Controlando
  la forma de acceder al estado.
date: '2017-10-17T02:57:00.000-07:00'
author: Jesús
tags:
- Programación Orientada a Objetos
- POO
- C#
- Propiedades
- Modificadores de acceso
- Encapsulamiento
modified_time: '2017-12-06T08:23:17.257-08:00'
blogger_id: tag:blogger.com,1999:blog-3773544929012013646.post-4196213420915311576
blogger_orig_url: https://codigo418.blogspot.com/2017/12/la-importancia-del-encapsulamiento_6.html
---

<h2>Descriptores de acceso. Controlando la forma de acceder al estado.</h2>Que una clase permita leer un valor a otra clase que lo requiera no quiere decir que lo pueda modificar. Y si una clase debe poder modificarlo no significa tampoco que lo pueda hacer de forma directa, sino que quizás debería utilizar <i>descriptores de acceso (assessors)</i>, también llamados <i>getters </i>and <i>setters </i>o <b><i>propiedades </i></b>en .Net.<br /><br />Usar propiedades es una buena práctica incluso cuando el acceso es directo, es decir, aunque lo único que hagamos sea devolver un valor en el get o asignar un valor en el set. Quién sabe si en un futuro vamos a necesitar un descriptor de acceso con implementación. En este caso sólo tendríamos que implementar la lógica en el get o en el set sin alterar la compatibilidad binaria. Para explicarlo mejor vamos a ver un ejemplo simple del uso de un descriptor de acceso.<br /><h3>Manos a la obra</h3>Imaginemos que tenemos el campo precio que nos guarda un valor de una cantidad de dinero. Si optamos por hacerla público el campo daremos acceso desde el exterior directamente al valor (estado interno del objeto), tanto de lectura como de escritura.<br /><script src="https://gist.github.com/jesuscampos/750c5dffdf508e014c83fafe1cdd5fa7.js"></script>Haciendo esto estamos definiendo para el mundo exterior una interfaz de acceso directo a nuestro valor, es decir, nos hemos comprometido a brindar este acceso para siempre (siempre que queramos respetar la compatibilidad binaria). En caso de que queramos aplicar una lógica de acceso a este valor proporcionando un descriptor de acceso, tendríamos que cambiar la interfaz y por consiguiente tendríamos de cambiar todos los clientes que usan nuestra clase y recompilar de nuevo sus ensamblados.<br /><h4>Encapsulando el campo</h4>Para encapsular la variable la hacemos privada e implementamos una propiedad cuyo get y set establecen la lógica de acceso a este valor. A la variable privada también se le conoce con el nombre de variable de <b>respaldo</b>.<br /><misnotas>Desde Net 3.0 podemos utilizar una sintaxis mucho más cómoda para este tipo de propiedades que no tienen lógica en sus accesos. Se trata de las <b>propiedades auto-implementadas</b>. El compilador se encargará de crear el campo de “respaldo” de forma transparente para nosotros: </misnotas><script src="https://gist.github.com/jesuscampos/9b5889c9f17c8519bc0a4f6bd31f7737.js"></script><h4>¿Y todo esto para qué? </h4>Ahora imaginemos que debido a un cambio en los criterios de diseño se establece una validación en la que si se intenta escribir una cantidad que sobrepasa un cierto valor debemos lanzar una excepción. Además, si el precio es negativo debemos guardar un 0.<br /><br />Al tener una propiedad podemos fácilmente agregar esta lógica:<br /><script src="https://gist.github.com/jesuscampos/b8bcb04119eec3ab32007b170ca1ddeb.js"></script>Es decir, se trata de separar el “respaldo” de: <br /><ul><li>la forma en que permitimos modificarla (set) y/o</li><li>la forma en que servimos el valor al llamante (get)</li></ul><h4>Accesos restringidos </h4>¿Por qué tener el mismo nivel de visibilidad para la lectura que para la escritura?<br /><br />Tenemos varias formas de romper esta simetría. No tenemos por qué implementar los dos accesos de una propiedad. Por ejemplo, la siguiente propiedad es de <b>sólo lectura</b>:<br /><script src="https://gist.github.com/jesuscampos/77af968008848ebe7397185f66b56f1b.js"></script>Y la siguiente de <b>sólo escritura</b>:<br /><script src="https://gist.github.com/jesuscampos/9afad5c23908ccec858b9aa8fe86c771.js"></script>También tenemos los accesos con distinto nivel de lectura y escritura. Por ejemplo, la siguiente propiedad tiene un get y un set, pero el set está limitado por el modificador <code>protected</code>, lo que restringe su acceso sólo para la propia clase y sus extensiones. Desde otras clases se comportará como una propiedad de sólo lectura.<br /><script src="https://gist.github.com/jesuscampos/7e2bb9bcf6bf8d4b7a50804f69f4fe36.js"></script>A parte de todo esto, también existen algunas otras razones más para decantarse por propiedades antes de utilizar campos. No voy a entrar a analizar cada una de ellas pero las dejo aquí por si alguien todavía no ve razones suficientes: <br /><ul><li>La reflexión es mucho más simple usando propiedades que campos. Así que si piensas trabajar con reflexión implementa mejor propiedades;</li><li>No puedes enlazar (Databind) contra campos. Sólo funcionan con propiedades;</li><li>Puedes implementar inicialización diferida (lazy initialization).</li></ul><h4>¿Cuándo tiene sentido usar campos públicos? </h4>Hasta el propio framework de .Net utiliza en algunas ocasiones campos públicos en lugar de propiedades. Si sabemos seguro que un valor nunca va a tener una lógica de acceso podemos permitir su acceso directo. Tal es el caso de los campos declarados como &lt;code&gt;const&lt;/code&gt; o &lt;code&gt;readonly&lt;/code&gt;, como por ejemplo el campo &lt;code&gt;string.Empty&lt;/code&gt; del Framework o el campo &lt;code&gt;Math.PI&lt;/code&gt;. No tiene mucho sentido aplicarle una lógica a su acceso de lectura. Y al ser constantes de sólo lectura nunca va a existir tampoco una lógica de acceso de escritura.<br /><br /><a href="https://codigo418.blogspot.com/2017/12/la-importancia-del-encapsulamiento_85.html">&gt;&gt; Ir a Parte 4. Encapsular constructores.</a><br /><a href="https://codigo418.blogspot.com/2017/12/la-importancia-del-encapsulamiento.html">&lt;&lt; Volver a Parte 2. Un ejemplo de encapsulamiento en la vida real.</a>